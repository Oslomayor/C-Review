# 海康威视C语言考题解析

> Aug 30th, 2018   WeChatAccount: CrazyEngineer
>
> 本人笔试的是BSP岗位，摘取了部分题目，以C语言为主

### 1.执行下述 main 函数后，输出结果是多少（） 

```C
int main()
{
    int i = 10;
    switch(i)
    {
        case 9: i++;
        case 10: i++;
        case 11: i++;
        default i++;
    }
    printf("result i = %d\n",i);
}
```

##### A. 10

##### B. 11

##### C. 12

##### D.13

**解析**：答案是 **D** ，case 语句后面没有加 break，因此从 case 10 进入，default 结束，一共经过了 3次 i++，结果是13.

### 2. 下面的程序在64位Linux系统环境中的输出结果是（） 

```C
#include <stdio.h>
#include <stdlib.h>
int main()
{
    char str[] = "hikvision";
    char *p = str;
    int n = 100;
    printf("%u,%u,%u,%u\n",sizeof(str),sizeof(p),sizeof(*p),sizeof(n));
}
```

##### A. 10,8,9,4

##### B. 9,4,9,4

##### C. 9,8,9,4

##### D. 10,8,1,4

**解析**： 答案是 **D** ，字符串“hikvision”实际储存时结尾有一个结束符'\0'，因此str的大小时10；注意是64位系统，在32位系统中指针的占用空间大小是4字节，但在64位系统中是8字节；至于 *p 所指向的内容当然是'h'这个字符，因此大小为1字节；最后 int 类型的变量占4字节.

### 3. 数值 0xdeadbeef 在小端字节序处理器的存储器中的存储方式是（）

##### A. XX00: dead XX04: beef

##### B. XX00: efbe XX04: adde

##### C. XX00: beef XX04: dead

##### D. XX00: adde XX04: efbe

**解析**： 答案是 **C** ，小端字节序的格式为 **地址低位存储低字节值** 

### 4. 若下面代码的 test 指针的值为 0x12345678，则 test_p[1] 的值是（）

```c
char test[8] = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08};
int *test_p = (int *)test;
```

##### A. 0x1234567C

##### B. 0x12345679

##### C. 0x12345678

##### D. 0x1234567A

**解析**： 答案是 **A** ，一个 char 型变量是4字节，int 型是8字节，将 char 型变量转换成 int 型，tesp_p[1] 实际指向的是 0x03 这个位置，因此 test_p[1] 的地址比 test 的地址大 4.

### 5. 下面程序的输出结果是（）

```C
#include <stdio.h>
#include <stdlib.h>
void swap(int *a, innt *b)
{
    int *t;
    t = a;
    a = b;
    b = t;
}
main()
{
    int x = 1,y = 2;
    int *p = &x, *q = &y;
    swap(p,q);
    printf("%d %d\n",*p,*q);
}
```

##### A. 1 2

##### B. 2 1

##### C. 2 2 

##### D. 1 1

**解析**： 答案是 **A** ，这个题有陷阱，只看函数名 swap() 就容易想当然地认为这个一个完成交换功能地函数，其实它根本就没有完成交换。swap() 这个子函数中，只交换了形参的地址，并没有真正交换 p 和 q 的内存地址，因此 p 和 q 指向的值也没有变化。如果要完成交换任务，按照题目本意应该这样写：

```C
// 调用函数写法 swap(&p,&q)；
// 通过指针的指针交换指针的地址来完成指针指向内容的交换
void swap(int **a,int **b)
{
    int *t;
    t = *a;
    *a = *b;
    *b = t;
}
```

其实有一种人类更容易理解的写法：

```c
// 调用函数写法 swap(p,q);
// 通过指针交换变量值的交换
void swap(int *a, innt *b)
{
    int t;
    t = *a;
    *a = *b;
    *b = t;
}
```

### 6. 下面程序的输出结果是（）

```C
#include <stdio.h>
#include <stdlib.h>
struct country
{
    int idx;
    char name[30];
}list[5] = {1,"China",2,"USA",3,"Russia",4,"England",5,"France"};
int main()
{
    int i;
    for(i=1;i<5;i=i+2)
    {
        printf("%d%c",list[i].idx,list[i].name[0]);
    }
}
```

##### A. 1C2U

##### B. 3U4E

##### C. 1C3U

##### D. 2U4E

**解析**： 答案是 **D** ，观察 for 循环的内容，该程序运行结果是输出 list[1].idx list[1].name[0] 和  list[3].idx list[3].name[0] ，对照定义的结构体内容，分别是 2U4E.

### 7. 定义 int a = (3 != 2); 则 a 的值是多少（）

##### A. 2

##### B. 1

##### C. 3

##### D. 0

**解析**： 答案是**B** ，表达式  (3 != 2) 的结果为 true，true 的值在 GCC 头文件  <stdbool.h>  中第34行的位置定义为 1

### 8. 执行语句 a = 30+20%3*2; 请问 a 的值是多少（）

##### A. 4

##### B. 64

##### C. 34

##### D. 32

**解析**： 答案是 **C** ，注意运算符优先级，取余数大于加法

### 9. （多选）在 func() 函数中申请的 static 型变量 V 有下述哪些特性（）

##### A. V存在于 func() 被调用的期间

##### B. V能被整个程序使用

##### C. V仅能被 func() 使用

##### D. V存在于整个程序的执行过程

**解析**： 答案是**C,D** ，补充一下关于 static 类型声明的知识。

**1.**  static  声明函数内部变量时，该变量只能被该函数调用，且 static 类型的变量不会随函数的退出而被销毁，但普通变量会随着所在的函数被调用和退出而存在和销毁。

**2.** static 声明全局变量时，该全局变量只对声明所在的文件可见，其它文件都无法访问。普通全局变量全局可访问，对整个程序可见。

**3.** static 声明函数时，该函数只对声明所在的文件可见，其它文件无法访问。普通函数的函数名全局可访问，对整个程序可见。

### 10. （多选）关于链表，正确的选项有（）

##### A. 在运行时可以动态添加

##### B. 查找元素不需要顺序查找

##### C. 物理空间不连续，空间开销更大

##### D. 可在任意节点插入元素

**解析**： 答案是**A，D** ，关于链表这种数据结构，在嵌入式编程中用的比较多，尤其是双向环形链表。

### 11. （多选）以下关于进程和线程的描述，正确的有（）

##### A. 进程有独立的地址空间，而线程没有

##### B. 进程切换比线程的开销小

##### C. 线程是程序执行的最小单位

##### D. 每个线程拥有自己的堆栈和局部变量

**解析**： 答案是**A,C,D** ，补充一下关于进程和线程的区别。

**1.** 进程是资源分配的最小单位，线程是程序执行的最小单位。

**2.** 进程有自己独立的地址空间，每启动一个进程，系统会分配给它地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作开销比启动一个线程大很多。同一个进程下的线程之间共享资源，它们有自己的堆栈和局部变量，但没有独立的地址空间。

**3.** 线程之间的通信更方便，同一个进程下的线程可以共享变量，而进程之间的通信要用管道、信号量、消息队列、共享内存等通信机制来完成。



> Aug 30th, 2018   WeChatAccount: CrazyEngineer
>
> 第二次笔试 DSP 

### 1. 下面不属于 cache 的映射方式的是（）

##### A. indirect-mapping (间接映射)

##### B. set-associate (组相联)

##### C. direct-mapping (直接映射)

##### D. full-associative (全关联)



### 2. 以下哪种不是线程间的通讯方式（）

##### A. 共享内存

##### B. 全局变量

##### C. 互斥锁

##### D. 信号量



### 3. 关于中断的描述正确的是（）

##### A. 中断下部分仍然是处于中断上下文中

##### B. 中断处理函数会先禁止本地中断，为了减小中断处理时间，应该减少在中断函数中的有延时的函数调用

##### C. 软中断，工作列队，tasklet 都可以用作中断下半部分处理机制

##### D. 其他都不对

 

### 4. (多选) 数字a1,a2,a3,a4,a5,a6,a7顺序入栈，出栈的数据为1，2，3，4，5，6，7，若 a3 为 2，以下正确的是（）

##### A. a4 可能为1

##### B. a1 可能为1

##### C. a2 可能为1

##### D. a2 可以为任意数

 

### 5. (多选) 下列关于 C 语言编译运行中内存空间的描述，正确的有哪些（）

##### A. stack, 栈用于存放程序临时创建的局部变量，包括函数中 static 声明的局部变量

##### B. .bss segment, BSS段用于存放程序中未初始化的全局变量

##### C.  heap, 堆用于存放进程运行中被动态分配的内存，堆的大小可动态扩展

##### D. .data segment 数据段用于存放程序中已初始化的全局变量

 

### 6. (多选) 关于 C 语言的说法正确的是（）

##### A. C 语言函数的静态局部变量，在该函数每次调用时都会被重新定义和初始化

##### B. C 语言中，动态库后缀一般为.a , 静态库后缀一般为 .so

##### C. C 语言程序都是从 main  函数开始的

##### D. C 语言字符串型数组可以存放字符串

 



## 其它公司相关题目补充

### HTTP协议表示重定向的响应状态码是（）

**A.** 202	**B.** 302	**C.** 304	**D.** 404





### 以下代码

```C
void func()
{
    static int val = 0;
}
```

其中 val 变量的内存地址位于：

**A.** 已初始化数据段	**B.** 未初始化数据段	**C.** 堆	**D.** 栈


 



### 数组定义为 int a[4];  则表达式（）是错误的

**A.** *a	**B.** a[0]	  **C.** a	**D.** a++





### (填空)以下程序运行在32位机器上，请计算sizeof的值

```c
void Func (char str[100])
{
    sizeof(str) = _____;
}
void *p = malloc(100);
sizeof(p) = _____;
```





### 冒泡排序的时间复杂度是

**A.** O(n*2)	**B.** O(n^3)	  **C.** O(nlog2(n))	**D.** O(n^2)





### 定义 int data[10]; 用插入法对其中的数据按从小到大排序





